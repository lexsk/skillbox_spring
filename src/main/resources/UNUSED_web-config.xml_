<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xmlns="http://www.springframework.org/schema/beans"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/mvc
                           http://www.springframework.org/schema/mvc/spring-mvc.xsd
                           http://www.springframework.org/schema/context
                           http://www.springframework.org/schema/context/spring-context.xsd ">

    <context:component-scan
            base-package="org.example.web"/> <!-- component-scan тэг по которому контэйнер инверсии контроля будет сканировать пакеты на наличие бинов -->
    <mvc:resources mapping="/**" location="classpath:images"/>

    <!--
    HandlerMapping выполняет мэппинг входящих запросов на обработчики,
    а также список pre- и post-процессоров, реализующих интерфейс
    HandlerInterceptor. HandlerAdapter помогает DispatcherServlet
    вызывать обработчик, сопоставленный с запросом, независимо
    от того, какой обработчик фактически был вызван
    <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/>
    <bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/>
    эти две строки аналогичны следующей <mvc:annotation-driven/>
    -->
    <mvc:annotation-driven/> <!-- необходимо указать для подключения аннотаций mvc -->

    <!--    <mvc:default-servlet-handler/>--> <!-- захватывает все запросы и возвращает http шаблоны в связке с ViewResolver -->

    <!-- определение ViewResolver. Из коробки ViewResolver работает с jsp. А мы хотим работать с html.
         получает запрос от контроллера, перенаправляет и возвращает соответствующие View обратно пользователю

        Преобразует строковые имена view непосредственно в объекты View.
        В связке эти два интерфейса позволяют избежать привязки приложения
        к специфической view-технологии. ViewResolver предоставляет маппинг
        между именами view и непосредственно View. Из нескольких
        ViewResolver можно создать цепь с порядком, задаваемым параметром
        order в конфигурации
    -->
    <!--    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">-->
    <!--        <property name="prefix" value="/WEB-INF/views/"/>-->
    <!--        <property name="suffix" value=".html"/>-->
    <!--    </bean>-->

    <!-- для обработки динамиеских html подключим Thymeleaf -->
    <bean class="org.thymeleaf.spring5.view.ThymeleafViewResolver">
        <property name="templateEngine" ref="templateEngine"/>
        <property name="characterEncoding" value="UTF-8"/>
        <property name="order" value="1"/>
    </bean>

    <!-- SpringTemplateEngine автоматически добавляет SpringStandardDialect -->
    <bean id="templateEngine" class="org.thymeleaf.spring5.SpringTemplateEngine">
        <property name="templateResolver" ref="templateResolver"/>
        <!-- Включение компилятора SpringEL в Spring 4.2.4 или новее может ускорить -->
        <!-- выполнение в большинстве сценариев, но может быть несовместимо с конкретными -->
        <!-- случаями, когда выражения на одной странице повторно используются в разных данных, -->
        <!-- так что этот флаг по умолчанию имеет значение «false» для более безопасной обратной -->
        <!-- совместимости. -->
        <property name="enableSpringELCompiler" value="true"/>
    </bean>

    <!-- SpringResourceTemplateResolver автоматически интегрируется с собственной           -->
    <!-- инфраструктурой Spring для обработки web-ресурсов и необходим SpringTemplateEngine -->
    <bean id="templateResolver"
          class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver">
        <property name="prefix" value="/WEB-INF/views/"/>
        <property name="suffix" value=".html"/>
        <!-- HTML - значение по умолчанию. Добавлено здесь для большей ясности.              -->
        <property name="templateMode" value="HTML"/>
        <!-- Cache страниц по-умолчанию имеет значение true. Установите в false, если хотите -->
        <!-- чтобы шаблоны автоматически обновлялись при их изменении.                       -->
        <property name="cacheable" value="true"/>
        <property name="characterEncoding" value="UTF-8"/>
    </bean>

    <!--    <mvc:view-controller path="/books/shelf" view-name="book_shelf"/>-->


    <!--
    HandlerInterceptor
    HandlerInterceptor нужен для того, чтобы выполнять какой-то
    дополнительный код перед или после выполнения метода
    обработчика, а также после полного завершения обработки запроса,
    когда тот пройдёт полный жизненный цикл. Для реализации
    интерцептора предоставляется интерфейс HandlerInterceptor
    или же класс-адаптер HandlerInterceptorAdapter
    <mvc:interceptors>
        <bean class="org.springframework.web.servlet.i18n.LocaleChangeInterceptor"/>
        <mvc:interceptor>
            <mvc:mapping path="/**"/>
            <mvc:exclude-mapping path="/admin/**"/>
            <bean class="org.springframework.web.servlet.theme.ThemeChangeInterceptor"/>
        </mvc:interceptor>
        <mvc:interceptor>
            <mvc:mapping path="/secure/*"/>
            <bean class="org.example.SecurityInterceptor"/>
        </mvc:interceptor>
    </mvc:interceptors>
    -->

    <!--
    HandlerExceptionResolver
    Если во время мэппинга запросов возникает ошибка или обработчик
    выбрасывает исключение, DispatcherServlet делегирует это цепочке
    HandlerExceptionResolver-бинов, которые решают ошибки
    и предоставляют альтернативную обработку запросов обычно
    различного вида error-response
    <bean id="simpleMappingExceptionResolver" class="org.springframework.web.servlet.handler.SimpleMappingExceptionResolver">
        <property name="exceptionMappings">
            <map>
                <entry key="DatabaseException" value="databaseError"/>
                <entry key="InvalidCreditCardException" value="creditCardError"/>
            </map>
        </property>
        <property name="defaultErrorView" value="error"/>
        <property name="exceptionAttribute" value="ex"/>
        <property name="warnLogCategory" value="example.MvcLogger"/>
    </bean>
    -->

</beans>